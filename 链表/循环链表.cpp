#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
/*
本文件只描述学习过程见到的形式，问题，以及解决思路，不会有完整代码
*/

/*一、单向整体循环链表
		和单向链表相似，不过单向链表的尾节点的指针域不指向NULL，而是指向头节点
	1、链表长度：设置两个指针，一个不动用来保存地址，另一个不断next，直到两个针再次相等
	2、插入：和普通单向链表无太大差别
	3、删除：和普通单向链表无太大差别
	4、查找：和普通单向链表无太大差别，但遍历一个循环即可
	5、销毁：设置指针销毁头节点后面节点时，循环结束条件改变
  二、单向部分循环
		也是链表存在循环，但是是部分循环，而非整个链表
	1、判断是否存在循环：设置快慢两个指针，快针每次走两个节点，慢针每次一个节点，若两针相遇，则存在
	2、判断循环部分的长度：在1的基础，设置两针（可以使用1中的两个），一个不动，一个next循环，再次相等即可
	3、判断从哪个节点开始进入循环： a.使用两个指针，慢指针每次走一步，快指针每次走两步。 
									b.如果链表中存在循环，那么快慢指针最终会在循环内的某个节点相遇。 
									c.相遇后，将一个指针移回链表头部，然后两个指针都以每次一步的速度移动。 
									d.当它们再次相遇时，相遇点就是循环的起点。 
					原理: 
					假设链表头到循环起点的距离为a，循环起点到快慢指针第一次相遇点的距离为b，相遇点再回到循环起点的距离为c。 
					当快慢指针第一次相遇时，慢指针走了a+b,快指针走了 a+b+c+b = a+2b+c。 由于快指针的速度是慢指针的两倍，所以: 2(a+b) = a+2b+c=>a=c。 
					因此，从链表头到循环起点的距离等于从相遇点到循环起点的距离。 
					所以，当快慢指针相遇后，将一个指针重置到头部，然后两个指针都以相同速度前进， 它们会在循环起点相遇。
	4、将循环链表转为非循环：先找到开始循环的节点，在找到循环体内的->next为该节点的节点，将->next赋值NULL
  三、双向循环链表
		顾名思义，问题与单项循环大差不差，解决方法类似，不过多赘述
*/
int main()
{
	return 0;
}